# ==========================================================================
# Building
# ==========================================================================

src := $(obj)

PHONY := _build
_build:

confcheck-y =

# Read auto.conf if it exists, otherwise ignore
-include $(O)/include/config/auto.conf

ifneq ($(O),linux/)
ifneq ($(filter $(MAKECMDGOALS),confcheck),)
$(O)/linux/.config: ;

-include $(O)/linux/.config
endif
endif

# Toolchain arguments
override ARCH := $(MKR_ARCH)
override KARCH := $(MKR_KARCH)
override ARCH_FLAGS := $(MKR_ARCH_FLAGS)
override CC := $(MKR_CC)
override CXX := $(MKR_CXX)
override KCC := $(MKR_KCC)
override cflags-y := $(MKR_CFLAGS)
override ldflags-y := $(MKR_LDFLAGS)

# Unexport variables exported by top makefile
unexport srctree objtree VPATH mkr-build-src
unexport quiet Q
unexport HOSTCC HOSTCXX HOSTCFLAGS HOSTCXXFLAGS
unexport AWK
unexport RCS_TAR_IGNORE KBUILD_EXTMOD
unexport mkr-config O obj

# Avoid leaking variables (the one passed on command-line) to sub-makes
MAKEOVERRIDES=

pkginst := $(CURDIR)/.mkr.inst
staging := $(O)/staging
rootfs := $(O)/rootfs
mksrcdir=$(shell $(srctree)/build-tools/mksrcdir.sh \
		"$(srctree)" "$(MKR_SRC_BASEDIR)" "$(1)")

MAKE_UNI := $(MAKE) -j 1

pkgdir := $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))
mkr-pkgmk := $(pkgdir)/Makefile

ifeq ($(mkr-pkgmk),)
$(error No Makefile or Kbuild for package $(obj))
endif

.mkr.makefile.deps: $(mkr-pkgmk) $(deps)
	$(Q)$(AWK) -f $(srctree)/build-tools/makefile-deps.awk $< > $@ || rm -f $@

-include .mkr.makefile.deps

# Define confcheck macros
not = $(if $(strip $(1)),,y)

confcheck-if = $(1) > /dev/null && { echo $(2); success=false; };

confcheck-ifnot = $(1) > /dev/null || { echo $(2); success=false; };

confcheck-tool = type $(1) > /dev/null 2>&1 || { \
	echo Error: Command $(1) not found, install it or see $(2); \
	success=false; };
confcheck-not-empty = test x"$($(strip $(1)))" != x > /dev/null 2>&1 || { \
	echo Error: Variable $(1) can not be empty; success=false; };
confcheck-exists = test -e $(1) > /dev/null 2>&1 || { \
	echo Error: File $(1) not found, see $(2); success=false; };

# Macro for recursing
recurse = $(Q)failcom='exit 1'; success=:; \
	for f in x $$MAKEFLAGS; do \
		case $$f in \
			*=* | --[!k]*);; \
			*k*) failcom='success=false';; \
		esac; \
	done; \
	for target in $(1); do \
		echo $(2) $$target; \
		$(2) $$target || eval $$failcom; \
	done; \
	$$success

cross := $(shell expr $(CC) : '\(.*\)gcc')
kcross := $(shell expr $(KCC) : '\(.*\)gcc')

configure-args-y = \
	--host="$(MKR_CONFIGURE_HOST)" \
	--prefix=/usr \
	CC="$(CC)" CXX="$(CXX)" LD="$(cross)ld" AR="$(cross)ar" \
	STRIP="$(cross)strip" NM="$(cross)nm" RANLIB="$(cross)ranlib" \
	CFLAGS="$(cflags-y)" LDFLAGS="$(ldflags-y)"

include $(mkr-pkgmk)

ifneq ($(mkr-build-src),)
# Create output directory if not already present
_dummy := $(shell [ -d $(O)/$(obj) ] || mkdir -p $(O)/$(obj))

# Create directories for object files if directory does not exist
# Needed when obj-y := dir/file.o syntax is used
_dummy := $(foreach d,$(obj-dirs), $(shell [ -d $(O)/$(d) ] || mkdir -p $(O)/$(d)))
endif

ifndef obj
$(warning kbuild: Makefile.pkgbuild is included improperly)
endif

# Default rules
.PHONY: confcheck
confcheck:

.PHONY: default-confcheck
default-confcheck:
	$(Q)success=:;$(confcheck-y) $$success

.PHONY: staging
staging:

# Rules for building autoconf packages
# Use an improbable stamp name in order to avoid conflicts with
# packages with custom rules.
.mkr.autotools.default.configured: $(deps)
	rm -Rf * || :
	$(srcdir)/configure $(configure-args-y) && : > $@

.PHONY: default-autotools-compile
default-autotools-compile: .mkr.autotools.default.configured
	$(MAKE)

.PHONY: default-autotools-staging
default-autotools-staging:
	$(MAKE) DESTDIR=$(pkginst) install

.PHONY: rootfs
rootfs:

.PHONY: default-copyall-rootfs
default-copyall-rootfs:
	$(Q)if ! ( mkdir -p $(rootfs); cd $(staging); \
		    rsync -lptgodDR `cat $(CURDIR)/.mkr.dirlist $(CURDIR)/.mkr.filelist` $(rootfs); ); then \
		echo Error: rsync failed, please try again; \
		rm .mkr.fakeroot; \
		cat .mkr.filelist | \
		{ cd staging; xargs -r rm -f; } > /dev/null 2>&1; \
		cat .mkr.filelist | \
		{ cd rootfs; xargs -r rm -f; } > /dev/null 2>&1; \
		cat .mkr.dirlist | { cd staging; xargs -r \
		rmdir --ignore-fail-on-non-empty; } > /dev/null 2>&1; \
		cat .mkr.dirlist | { cd rootfs; xargs -r \
		rmdir --ignore-fail-on-non-empty; } > /dev/null 2>&1; \
		exit 1; \
	fi

.PHONY: default-rootfs
default-rootfs:
	$(Q)if ! ( mkdir -p $(rootfs); cd $(staging); \
		rsync -lptgodDRr $(patsubst %,.%,$(rootfs-y)) $(rootfs); ); then \
			echo Error: rsync failed, please try again; \
			rm .mkr.fakeroot; \
			cat .mkr.filelist | \
			{ cd staging; xargs -r rm -f; } > /dev/null 2>&1; \
			cat .mkr.filelist | \
			{ cd rootfs; xargs -r rm -f; } > /dev/null 2>&1; \
			cat .mkr.dirlist | { cd staging; xargs -r \
			rmdir --ignore-fail-on-non-empty; } > /dev/null 2>&1; \
			cat .mkr.dirlist | { cd rootfs; xargs -r \
			rmdir --ignore-fail-on-non-empty; } > /dev/null 2>&1; \
			exit 1; \
		fi

.PHONY: default-clean
default-clean:
	$(Q)if test -e Makefile; then \
		$(MAKE) clean; \
	fi
